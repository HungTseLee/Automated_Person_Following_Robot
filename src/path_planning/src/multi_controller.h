#ifndef MULTI_CONTROLLER_H
#define MULTI_CONTROLLER_H

#include <iostream>
#include <geometry_msgs/Twist.h>


class controller
{
	private:
		double V_max;   // max linear velocity of the robot
		double W_max;   // max angular velocity of the robot
		double safety_R;   // safety distance between the person and robot 
		
		double V_input;   // the linear control input generated by controller
		double omega_input;   // the angular control input generated by controller

	public:
		controller();   // default constructor
		controller(double v_max, double w_max, double safety_r) : V_max(v_max), W_max(w_max), safety_R(safety_r), V_input(0), omega_input(0) {};
		controller(const controller&) = delete;
		~controller();
		
		// controller member function
		geometry_msgs::Twist Simple_P_controller(double Re, double Te);
		geometry_msgs::Twist Simple_PD_controller(double Re, double Te, double Re_pre, double Te_pre);   // this one might be the simplest choice with good performance
		geometry_msgs::Twist Improved_P_controller(double Re, double Te, double people_relative_linear_velocity, double robot_linear_velocity);
		geometry_msgs::Twist Nonlinear_controller_Feedback_linearization(double people_x, double people_y, double people_relative_linear_velocity, double people_relative_shift_velocity, double robot_linear_velocity);
		geometry_msgs::Twist Sigmoid_function_controller(double Re, double Te);
		geometry_msgs::Twist Improved_double_Sigmoid_controller(double Re, double Te);
		//geometry_msgs::Twist Fuzzy_controller(double Re, double Te);
		geometry_msgs::Twist MPC_controller(double Re, double Te);
		
		void limitation();    // verify the velocity limitation of the robot will not exceed max_V
		geometry_msgs::Twist command_publish();    // packing the control signal into a Twist msg type
};

#endif